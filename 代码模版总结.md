# Doppler 的代码模版

## 一 基础操作

1. 快读快写

```cpp
// 关闭同步流（加速）
ios::sync_with_stdio(false);
cin.tie(0);

更快但复杂的快读快写
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * w;
}
void write(int x) {
    if (x < 0)
    {
        x = -x;
        putchar('-');
    }
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
```

2. 二分

```cpp
int arr[N];
int binarySearch(int left, int right, int x) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == x) {
            return mid;
        }
        else if (arr[mid] < x) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
}
```

3. 整数转换为字符串

```cpp
int x;
bool f = to_string(x).find("123") != string::npos;
```

## 二 数论

1. 乘法取模

```cpp
ll mul(ll a, ll b, ll m)
{
    a = a % m, b = b % m;
    ll res = 0;
    while (b > 0) {
        if (b & 1) res = (res + a) % m;
        a = (a + a) % m;
        b >>= 1;
    }
    return res;
}
```

2. 快速幂取模 fastPow(a, n, m) = (a^n)%m

```cpp
ll fastPow(ll a, ll n, ll mod) // (a^n)%m
{
    ll ans = 1;
    a %= mod;
    while (n) {
        if (n & 1)ans = (ans * a) % mod;
        a = (a * a) % mod;
        n >>= 1;
    }
    return ans;
}
```

3. 矩阵乘法&快速幂

```cpp
int mod;
struct matrix { int m[N][N]; };
matrix operator * (const matrix& a, const matrix& b) {
    matrix c;
    memset(c.m, 0, sizeof(c.m));
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            for (int k = 0; k < N; k++)
                c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;
    return c;
}
matrix pow_matrix(matrix a, int n)
{
    matrix ans;
    memset(ans.m, 0, sizeof(ans.m));
    for (int i = 0; i < N; i++)
        ans.m[i][i] = 1;
    while (n) {
        if (n & 1) ans = ans * a;
        a = a * a;
        n >>= 1;
    }
    return ans;
}
```

4. GCD & LCM

`裴蜀定理` 如果 a 和 b 均为整数，则有整数 x 和 y 使 ax+by=gcd(a,b)；ab 互素当且仅当存在 x 和 y 使得 ax+by=1
```cpp
int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

5. 扩展欧几里得

ax+by=c 有解的充要条件是 d=gcd(a,b) 能整除 c
扩展欧几里得算法求解二元丢番图方程，进而求解 ax+by=c 的特解
   1. 判断方程是否有整数解，即 d 能整除 c
   2. exgcd 求 ax+by=d 的特解 xx 和 yy
   3. axx+byy=d 两边同乘 c/d，对照 ax+by=c，得特解 xx‘=xx*c/d，yy’=yy*c/d
   4. 方程 ax+by=c 的通解为 x = xx‘+(b/d)n, y = yy'-(a/d)n
```cpp
ll extend_gcd(ll a, ll b, ll& x, ll& y) // 返回 d=gcd(a,b), x 和 y 是 ax+by=d 的一组特解
{
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = extend_gcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

6. 求解同余方程（求逆）

```cpp
ll mod_inverse(ll a, ll m) // ax===1(mod m)
{
    ll x, y;
    extend_gcd(a, m, x, y);
    return (x % m + m) % m;
}
```

7. 费马小定理

设 n 为素数，a 是正整数且与 n 互素，则有 a^(n-1)===1(mod n)
```cpp
ll mod_inverse(ll a, ll mod)
{
    return fastPow(a, mod - 2, mod);
}
```

8. Miller-Rabin 素性测试

```cpp
ll fastPow();
bool witness(ll a, ll n)
{
    ll u = n - 1;
    int t = 0;
    while (u & 1 == 0) u >>= 1, t++;
    ll x1, x2;
    x1 = fastPow(a, u, n);
    for (int i = 1; i <= t; i++) {
        x2 = fastPow(x1, 2, n);
        if (x2 == 1 && x1 != 1 && x1 != n - 1) return true;
        x1 = x2;
    }
    if (x1 != 1) return true;
    return false;
}
int miller_rabin(ll n, int s)
{
    if (n < 2) return 0;
    if (n == 2) return 1;
    if (n % 2 == 0) return 0;
    for (int i = 0; i < s && i < n; i++) {
        ll a = rand() % (n - 1) + 1;
        if (witness(a, n)) return 0;
    }
    return 1;
}
void solve() // main
{
    int m;
    while (scanf("%d", &m) != EOF) {
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            ll n;
            scanf("%lld", &n);
            int s = 50;
            cnt += miller_rabin(n, s);
        }
        printf("%d\n", cnt);
    }
}
```

9. 欧拉筛

```cpp
int prime[N];
bool vis[N];
int euler_sieve(int n)
{
    int cnt = 0;
    memset(prime, 0, sizeof(prime));
    memset(vis, 0, sizeof(vis));
    for (int i = 2; i <= n; i++) {
        if (!vis[i]) prime[cnt++] = i;
        for (int j = 0; j < cnt; j++) {
            if (i * prime[j] > n) break;
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    return cnt;
}
```

10. 欧拉函数

威尔逊定理：若 p 为素数，则 p 可以整除 (p-1)!+1
```cpp
int euler(int n) // 求欧拉函数值
{
    int ans = n;
    for (int p = 2; p * p <= n; ++p) {
        if (n % p == 0) {
            ans = ans / p * (p - 1);
            while (n % p == p)
                n /= p;
        }
    }
    if (n != 1) ans = ans / n * (n - 1);
    return ans;
}
```

11. 二项式定理&卢卡斯定理

二项式定理：C(n,r)%m=(n! mod m)((r!)^(-1) mod m)((n-r!)^(-1) mod m) mod m
卢卡斯定理：要求 m 为素数
```cpp
ll fac[N];
ll fastPow(ll a, ll n, ll m)
{
    ll ans = 1;
    a %= m;
    while (n) {
        if (n & 1) ans = (ans * a) % m;
        a = (a * a) % m;
        n >>= 1;
    }
    return ans;
}
ll inverse(ll a, int m) { return fastPow(fac[a], m - 2, m); }
ll C(ll n, ll r, int m)
{
    if (r > n) return 0;
    return ((fac[n] * inverse(r, m)) % m * inverse(n - r, m) % m);
}
ll lucas(ll n, ll r, int m)
{
    if (r == 0) return 1;
    return C(n % m, r % m, m) * lucas(n / m, r / m, m) % m;
}
```

12. Bash Game

```cpp
void Bash_game()
{
    int n, m; // 共 n 个，每次最多拿 m 个
    cin >> n >> m;
    if (n % (m + 1) == 0) cout << "second\n";
    else cout << "first\n";
}
```

13. 素数筛 O(n)

```cpp
int cnt = 0, prime[N], v[N];
for(int i = 2; i <= n; i++) {
    if(v[i] == 0) {
        v[i] = i;
        prime[++cnt] = i;
    }
    for(int j = 1; j <= cnt; j++) {
        if(prime[j] > v[i] || i * prime[j] > n) break; // 保证每一个合数都是被他的最小质因子筛掉
        v[i * prime[j]] = prime[j]; // v[i]表示i的最小质因子
    }
}
```



## 三 图论

1. Floyd 适用**最短路存在**的任何图，f[i][j] 为所求最短路长度

```cpp
void floyd() {
    int f[N][N];
    for (int k = 1; k <= n; k++) {
        for (int x = 1; x <= n; x++) {
            for (int y = 1; y <= n; y++) {
                f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
            }
        }
    }
}
```

2. Bellman_Ford 可以求出有负权的图的最短路，或对最短路不存在的情况进行判断

```cpp
struct edge {
    int v, w;
};
vector<edge> e[N];
int dis[N], cnt[N], vis[N];
queue<int> q;
bool spfa(int n, int s) {
    memset(dis, 63, sizeof(dis));
    dis[s] = 0, vis[s] = 1;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop(), vis[u] = 0;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                cnt[v] = cnt[u] + 1;  // 记录最短路经过的边数
                if (cnt[v] >= n) return false;
                // 在不经过负环的情况下，最短路至多经过 n - 1 条边
                // 因此如果经过了多于 n 条边，一定说明经过了负环
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
    return true;
}
```
更新部分的另一种写法
```cpp
if(dis[v] > dis[u] + w) {
	dis[v] = dis[u] + w;
	if(!vis[v]) {
		vis[v] = 1;
		q.push(v);
		cnt[v]++;
		if(cnt[v] >= n) return false;
	}
}
```
**差分约束**
形如 `a - b >= c` 的约束条件，在图中添加有向边 `ed[a].push_back({b, -c});
对于 `a - b <= c`，添加 `ed[u].push_back({a, c});` 
对于 `a == b`，添加 a b 之间权值为 0 的边即可。

建图完成后，以 0 为起点跑一边 SPFA，若存在负环，则无解。否则，xi = dis[i] 为该差分约束系统的一组解。



3. Dijkstra 求解非赋权图单源最短路

```cpp
struct edge {
    int v, w;
};
struct node {
    int dis, u;
    bool operator>(const node& a) const { return dis > a.dis; }
};
vector<edge> e[N];
int dis[N], vis[N];
priority_queue<node, vector<node>, greater<node> > q;
void dijkstra(int n, int s)
{
    memset(dis, 63, sizeof(dis));
    dis[s] = 0;
    q.push((node) { 0, s });
    while (!q.empty()) {
        int u = q.top().u;
        q.pop();
        if (vis[u])
            continue;
        vis[u] = 1;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push((node) { dis[v], v });
            }
        }
    }
}
```

4. Kruskal

```cpp
const int N = 2e3 + 5;
struct edge {
    int u, v, w;
    bool operator> (const edge& a) const { return w > a.w; }
};
priority_queue<edge, vector<edge>, greater<edge> > q; // 边集按权值排序
vector<edge> mp;
int fa[N];
int n, m, ans = 0;
int find(int x) { // 并查集判环
    int root = fa[x];
    while (root != fa[root]) root = fa[root];
    while (x != root) {
        int t = fa[x];
        fa[x] = root;
        x = t;
    }
    return root;
}
void Kruskal() {
    for (int i = 1; i <= n; i++) fa[i] = i;
    while (mp.size() < n - 1 && !q.empty()) { // 克鲁斯卡尔
        edge ed = q.top();
        q.pop();
        int u = find(ed.u), v = find(ed.v);
        if (u != v) {
            mp.push_back(ed);
            ans += ed.w;
            fa[u] = fa[v];
        }
    }
}
int main()
{
    cin >> n >> m;
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        q.push((edge) { u, v, w });
    }
    Kruskal();
    if (mp.size() < n - 1 && q.empty()) {
        cout << "无法构成最小生成树";
        return 0;
    }
    cout << "总权值：" << ans << endl;
    cout << "构成最小生成树的边是：" << endl;
    for (auto e : mp)
        printf("%d %d %d\n", e.u, e.v, e.w);
    return 0;
}
```

5. prim

```cpp
const int N = 5e3 + 5;
struct edge {
    int v, w;
    bool operator> (const edge& e) const { return w > e.w; }
};
int n, m;
ll ans = 0;
bool vis[N];
vector<edge> ed[N];
void prim(int s) {
    int cnt = 1;
    vis[s] = 1;
    priority_queue<edge, vector<edge>, greater<edge> > q;
    for (auto e : ed[s])
        q.push(e);
    while (!q.empty() && cnt < n) {
        edge e = q.top();
        q.pop();
        if (vis[e.v]) continue;
        for (auto e : ed[e.v])
            q.push(e);
        ans += e.w;
        vis[e.v] = 1;
    }
}
int main()
{
    cin >> n >> m;
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        ed[u].push_back((edge) { v, w });
        ed[v].push_back((edge) { u, w });
    }
    prim(1);
    for (int i = 1; i <= n; i++)
        if (!vis[i]) {
            cout << "impossible";
            return 0;
        }
    cout << ans << endl;
    return 0;
}
```

6. 拓扑排序（常用BFS判环）

```cpp
vector<int> ed[N]; // 存图
int in[N]; // 保存入度
bool vis[N];
int main()
{
	int n, m;
    cin >> n >> m;
    while(m--) {
		int u, v;
        cin >> u >> v;
        ed[u].push_back(v);
        in[v]++;
    }
    queue<int> q;
    for(int i = 1; i <= n; i++) {
        if(ed[i] == 0)
            q.push(i);
    }
    while(!q.empty()) {
        int u = q.front();
        vis[u] = 1;
        q.pop();
        for(auto v : ed[u]) {
            if(vis[v] || in[v] == 0) continue;
            in[v]--;
            vis[v] = 1;
            q.push(v);
        }
    }
    if(q.size() != n) cout << "有环\n"; // 输出q的内容即为拓扑排序的结果
}
```
7. 同余最短路

处理「给定 n 个整数，求这 n 个整数能拼凑出多少的其他整数（n 个整数可以重复取）」，以及「给定 n 个整数，求这 n 个整数不能拼凑出的最小（最大）的整数」，或者「至少要拼几次才能拼出模 K 余 p 的数」的问题。

状态转移：f(i + y) = f(i) + y
```cpp
// 例题：luogu跳楼机：给定 h，从 1 开始，可以加 x、y、z，问有多少组 abc，使得 1 < ax+by+cz <= h
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, k, j) for(int i = (k); i >= (j); i--)
#define ll long long
using namespace std;
const int N = 1e5 + 5;
const ll llINF = 0x3f3f3f3f3f3f3f3f;
struct edge {
    ll v, w;
};
vector<edge> ed[N];
ll h, dis[N];
ll x, y, z;
bool vis[N];
void spfa() {
    dis[1] = 1;
    vis[1] = 1;
    queue<ll> q;
    q.push(1);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (auto e : ed[u]) {
            int v = e.v, w = e.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
}
void solve()
{
    memset(dis, llINF, sizeof(dis));
    cin >> h >> x >> y >> z;
    if (x == 1 || y == 1 || z == 1) {
        cout << h << '\n';
        return;
    }
    rep(i, 0, x - 1) {
        ed[i].push_back({(i + y) % x, y}); // 加边
        ed[i].push_back({(i + z) % x, z});
    }
    spfa(); // 跑一边单源最短路
    ll ans = 0;
    rep(i, 0, x - 1) {
        if (h >= dis[i]) {
            ans += (h - dis[i]) / x + 1;
        }
    }
    cout << ans << '\n';
}
int main()
{
    int T_T = 1;
    // cin >> T_T;
    while (T_T--)
        solve();
    return 0;
}
```




## 四 字符串

1. manacher 求最长回文子串

```cpp
int n, P[N << 1];
char a[N], S[N << 1];
void change()
{
    n = strlen(a);
    int k = 0; S[k++] = '$'; S[k++] = '#';
    for (int i = 0; i < n; i++) { S[k++] = a[i]; S[k++] = '#'; }
    S[k++] = '&';
    n = k;
}
void manacher()
{
    int R = 0, c;
    for (int i = 1; i < n; i++) {
        if (i < R) P[i] = min(P[(c << 1) - i], P[c] + c - i);
        else P[i] = 1;
        while (S[i + P[i]] == S[i - P[i]]) P[i]++;
        if (P[i] + i > R) {
            R = P[i] + i;
            c = i;
        }
    }
}
void solve()
{
    cin >> a; change();
    manacher();
    int ans = 1;
    for (int i = 0; i < n; i++) ans = max(ans, P[i]);
    cout << ans - 1 << endl;
    return;
}
```

## 五 树

## 六 数据结构

1. Trie 字典树

```cpp
template <typename Key, typename Value>
class TrieNode {
public:
    map<Key, TrieNode*> children; // 子节点字典树  
    Value data; // 节点数据  
    bool isEndOfWord; // 是否为单词结尾  
};
template <typename Key, typename Value>
class Trie {
private:
    TrieNode<Key, Value>* root; // 根节点  
public:
    Trie() {
        root = new TrieNode<Key, Value>(); // 初始化根节点  
    }
    // 插入一个单词到字典树中  
    void insert(string word) {
        TrieNode<Key, Value>* node = root;
        for (int i = 0; i < word.length(); i++) {
            Key key = word[i]; // 取单词的每个字符作为 key  
            if (node->children.find(key) == node->children.end()) { // 如果子节点不存在，则创建新的子节点  
                node->children[key] = new TrieNode<Key, Value>();
            }
            node = node->children[key]; // 移动到子节点处  
        }
        node->data = word; // 将单词的值保存到节点中  
        node->isEndOfWord = true; // 标记单词结尾  
    }
    // 查找一个单词是否在字典树中  
    bool search(string word) {
        TrieNode<Key, Value>* node = root;
        for (int i = 0; i < word.length(); i++) {
            Key key = word[i]; // 取单词的每个字符作为 key  
            if (node->children.find(key) == node->children.end()) { // 如果子节点不存在，则返回 false  
                return false;
            }
            node = node->children[key]; // 移动到子节点处  
        }
        return (node != NULL && node->isEndOfWord); // 如果找到了单词且单词结尾标记为 true，则返回 true，否则返回 false  
    }
};
```

2. 并查集

```cpp
int fa[N];
int find(int x)
{
    int root = fa[x];
    while (root != fa[root]) root = fa[root];
    while (x != root) {
        int t = fa[x];
        fa[x] = root;
        x = t;
    }
    return root;
}
void solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) fa[i] = i;
    for (int i = 0; i < m; i++) {
        int x, y, z;
        cin >> z >> x >> y;
        if (z == 1) {
            int u = find(x);
            int v = find(y);
            fa[u] = fa[v];
        }
        else {
            if (find(x) == find(y)) {
                cout << "Y\n";
            }
            else {
                cout << "N\n";
            }
        }
    }
}
```

3. 树状数组

单点修改、区间求和

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 5e5 + 5;

int tr[N], n;

int lowbit(int x) { return x & -x; }
void add(int x, int y) {
    for(; x <= n; x += lowbit(x))
        tr[x] += y;
}
int query(int x) {
    int ans = 0;
    for(; x; x -= lowbit(x))
        ans += tr[x];
    return ans;
}

int main()
{
    int q;
    cin >> n >> q;
    for(int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        add(i, x);
    }
    while(q--) {
        int op;
        cin >> op;
        if(op == 1) {
			int x, k;
            cin >> x >> k;
            add(x, k);
        }
        else {
            int x, y;
            cin >> x >> y;
            cout << query(y) - query(x - 1) << '\n';
        }
    }
    return 0;
}
```

4. 线段树

线段树模板
```cpp
#include <bits/stdc++.h>
#define lson (x << 1)
#define rson (x << 1 | 1)
#define ll long long
const int N = 1e5 + 5;
int n, m;
ll a[N], d[N << 2], lazy[N << 2];
void build(int l, int r, int x) {
    if (l == r) { d[x] = a[l]; return; }
    int mid = ((r - l) >> 1) + l;
    build(l, mid, lson);
    build(mid + 1, r, rson);
    d[x] = d[lson] + d[rson];
}
void update(int l, int r, int x, ll k, int L, int R) {
    if (l <= L && R <= r) {
        d[x] += k * (R - L + 1);
        lazy[x] += k;
        return;
    }
    int mid = ((R - L) >> 1) + L;
    if (lazy[x] && L != R) {
        d[lson] += lazy[x] * (mid - L + 1);
        d[rson] += lazy[x] * (R - mid);
        lazy[lson] += lazy[x];
        lazy[rson] += lazy[x];
        lazy[x] = 0;
    }
    if (l <= mid) update(l, r, lson, k, L, mid);
    if (r >= mid + 1) update(l, r, rson, k, mid + 1, R);
    d[x] = d[lson] + d[rson];
}
ll get(int l, int r, int x, int L, int R) {
    if (l <= L && R <= r) {
        return d[x];
    }
    int mid = ((R - L) >> 1) + L;
    ll res = 0;
    if (lazy[x]) {
        d[lson] += lazy[x] * (mid - L + 1);
        d[rson] += lazy[x] * (R - mid);
        lazy[lson] += lazy[x];
        lazy[rson] += lazy[x];
        lazy[x] = 0;
    }
    if (l <= mid) res += get(l, r, lson, L, mid);
    if (r >= mid + 1) res += get(l, r, rson, mid + 1, R);
    return res;
}
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    build(1, n, 1);
    while (m--) {
        int op, l, r;
        std::cin >> op >> l >> r;
        if (op == 1) {
            ll k;
            std::cin >> k;
            update(l, r, 1, k, 1, n);
        }
        else {
            std::cout << get(l, r, 1, 1, n) << std::endl;
        }
    }
}
```


5. 分块

区间加法、单点查值

```cpp
int n, par; // par为区块长度
int belong[N]; // 记录所属区块
int l[MAXPAR], r[MAXPAR];
int part[MAXPAR];
void build() {
    par = sqrt(n);
    int cnt = n / par;
    int ptop = 1;
    for(int i = 1; i <= cnt; i++) {
        l[i] = ptop;
        for(int j = 1; j <= par; j++)
            belong[ptop++] = i;
        r[i] = ptop - 1;
    }
    while(ptop <= n) // 最右侧多余的部分
        belong[ptop++] = cnt;
    r[cnt] = n;
}
void add(int L, int R, int c) {
    if(belong[L] == belong[R]) {
        for(int i = L; i <= R; i++)
            a[i] += c;
    }
    else {
        for(int i = L; i <= r[belong[L]]; i++)
            a[i] += c;
        for(int i = l[belong[R]]; i <= R; i++)
            a[i] += c;
        for(int i = belong[L] + 1; i <= belong[R] - 1; i++)
            part[i] += c;
    }
}
```



## 七 组合数学

1. 斯特林数

第二类斯特林数：S(n,k), 把 n 个不同的球放到 k 个相同的盒子里，不能有空盒子，有多少种分法

+ 求 S(n, m)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 2e5 + 5;
const ll inf = 1ll << 62;
const ll mod = 1e9 + 7;
ll fac[100010], inv[100010];
void add(ll& a, ll b) {
    a += b;
    if (a >= mod) a -= mod;
}
ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}
ll qmi(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
    }
    return res;
}
ll f(string s, string t) {
    ll p = 0;
    for (ll i = 0; i < s.size(); i++)
        if (p < t.size() && s[i] == t[p]) {
            p++;
        }
    return (p == t.size());
}
void sub(ll& a, ll b) {
    a -= b;
    if (a < 0) a += mod;
}
ll C(ll a, ll b) {
    return fac[a] * inv[b] % mod * inv[a - b] % mod;
}
void solve() {
    ll n, m; cin >> n >> m;
    if (m > n)
        cout << 0 << endl;
    else {
        ll ans = 0;
        for (int i = 0; i <= m; i++) {
            if ((m - i) % 2 == 0) {
                add(ans, qmi(i, n) * inv[i] % mod * inv[m - i] % mod);
            }
            else {
                sub(ans, qmi(i, n) * inv[i] % mod * inv[m - i] % mod);
            }

        }
        cout << ans << endl;
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    fac[0] = inv[0] = 1;
    for (int i = 1; i <= 100000; i++)
        fac[i] = fac[i - 1] * i % mod;
    inv[100000] = qmi(fac[100000], mod - 2);
    for (int i = 100000; i >= 1; i--)
        inv[i - 1] = inv[i] * i % mod;
    solve();
}
```