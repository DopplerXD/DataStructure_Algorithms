# 板子补充

## 线段树

```cpp
template<class T> struct Segt {
    struct node {
        int l, r;
        T w, rmq, lazy;
    };
    std::vector<T> w;
    std::vector<node> t;

    Segt() {}
    Segt(int n) { init(n); }
    Segt(std::vector<int> in) {
        int n = in.size() - 1;
        w.resize(n + 1);
        for (int i = 1; i <= n; i++) {
            w[i] = in[i];
        }
        init(in.size() - 1);
    }
    
    #define GL (k << 1)
    #define GR (k << 1 | 1)
    
    void init(int n) {
        w.resize(n + 1);
        t.resize(n * 4 + 1);
        auto build = [&](auto self, int l, int r, int k = 1) {
            if (l == r) {
                t[k] = {l, r, w[l], w[l], -1};
                return;
            }
            t[k] = {l, r};
            int mid = (l + r) / 2;
            self(self, l, mid, GL);
            self(self, mid + 1, r, GR);
            pushup(k);
        };
        build(build, 1, n);
    }
    void pushdown(node &p, T lazy) {
        p.w += (p.r - p.l + 1) * lazy;
        p.rmq += lazy;
        p.lazy += lazy;
    }
    void pushdown(int k) {
        if (t[k].lazy == -1) return;
        pushdown(t[GL], t[k].lazy);
        pushdown(t[GR], t[k].lazy);
        t[k].lazy = -1;
    }
    void pushup(int k) {
        auto pushup = [&](node &p, node &l, node &r) {
            p.w = l.w + r.w;
            p.rmq = min(l.rmq, r.rmq); // RMQ -> min/max
        };
        pushup(t[k], t[GL], t[GR]);
    }
    void modify(int l, int r, T val, int k = 1) {
        if (l <= t[k].l && t[k].r <= r) {
            pushdown(t[k], val);
            return;
        }
        pushdown(k);
        int mid = (t[k].l + t[k].r) / 2;
        if (l <= mid) modify(l, r, val, GL);
        if (mid < r) modify(l, r, val, GR);
        pushup(k);
    }
    T rmq(int l, int r, int k = 1) {
        if (l <= t[k].l && t[k].r <= r) {
            return t[k].rmq;
        }
        pushdown(k);
        int mid = (t[k].l + t[k].r) / 2;
        T ans = numeric_limits<T>::lowest(); // RMQ -> 为 max 时需要修改为 ::max()
        if (l <= mid) ans = min(ans, rmq(l, r, GL)); // RMQ -> min/max
        if (mid < r) ans = min(ans, rmq(l, r, GR)); // RMQ -> min/max
        return ans;
    }
    T ask(int l, int r, int k = 1) { // 区间询问
        if (l <= t[k].l && t[k].r <= r) {
            return t[k].w;
        }
        pushdown(k);
        int mid = (t[k].l + t[k].r) / 2;
        T ans = 0;
        if (l <= mid) ans += ask(l, r, GL);
        if (mid < r) ans += ask(l, r, GR);
        return ans;
    }
    void debug(int k = 1) {
        std::cout << "[" << t[k].l << ", " << t[k].r << "]: ";
        std::cout << "w = " << t[k].w << ", ";
        std::cout << "Min = " << t[k].rmq << ", ";
        std::cout << "lazy = " << t[k].lazy << ", ";
        std::cout << std::endl;
        if (t[k].l == t[k].r) return;
        debug(GL), debug(GR);
    }
};
```

## 归并排序求逆序对数

```cpp
int tmp[N];
void mergeSort(int l, int r, std::vector<int>& a, int& ans) {
    if (l >= r) return;
    int mid = (l + r) >> 1, i = l, j = mid + 1, cnt = 0;
    mergeSort(l, mid, a, ans);
    mergeSort(mid + 1, r, a, ans);
    while (i <= mid || j <= r)
        if (j > r || (i <= mid && a[i] <= a[j]))
            tmp[cnt++] = a[i++];
        else
            tmp[cnt++] = a[j++], ans += mid - i + 1;
    for (int k = 0; k < r - l + 1; k++)
        a[l + k] = tmp[k];
}
```

## ST 表

### ST 表

```cpp
int n, a[N];
int mx[N][20];
int mylog[N];

init() {
    mylog[0] = -1;
    for(int i = 1; i < N; i++) mylog[i] = mylog[i >> 1] + 1;
    
    for(int k = 1; (1 << k) <= n; k++)
        for(int i = 1; i + (1 << k) - 1 <= n; i++)
            mx[i][k] = max(mx[i][k - 1], mx[i + (1 << (k - 1))][k - 1]);
}
```

### 二维 ST 表

#### 固定子矩阵边长求最值

```cpp
// https://vjudge.net/problem/OpenJ_Bailian-2019
int n, b, m;
int mn[N][N][10], mx[N][N][10];
int mylog[N];
int a[N][N];

void solve() {
    memset(mn, 63, sizeof(mn));
    cin >> n >> b >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
            mn[i][j][0] = mx[i][j][0] = a[i][j];
        }
    }
    for (int k = 1; (1 << k) <= n; k++) //枚举区间长度
        for (int i = 1; i + (1 << k) - 1 <= n; i++)
            for (int j = 1; j + (1 << k) - 1 <= n; j++) {
                mn[i][j][k] = min(mn[i][j][k - 1], min(mn[i + (1 << (k - 1))][j][k - 1], min(mn[i][j + (1 << (k - 1))][k - 1], mn[i + (1 << (k - 1))][j + (1 << (k - 1))][k - 1])));
                mx[i][j][k] = max(mx[i][j][k - 1], max(mx[i + (1 << (k - 1))][j][k - 1], max(mx[i][j + (1 << (k - 1))][k - 1], mx[i + (1 << (k - 1))][j + (1 << (k - 1))][k - 1])));
            }
    int k = log2(b);
    while (m--) {
        int x, y;
        cin >> x >> y;
        int MN = 1e9, MX = 0;
        MN = min(MN, mn[x][y][k]);
        MN = min(MN, mn[x][y + b - (1 << k)][k]);
        MN = min(MN, mn[x + b - (1 << k)][y][k]);
        MN = min(MN, mn[x + b - (1 << k)][y + b - (1 << k)][k]);
        MX = max(MX, mx[x][y][k]);
        MX = max(MX, mx[x][y + b - (1 << k)][k]);
        MX = max(MX, mx[x + b - (1 << k)][y][k]);
        MX = max(MX, mx[x + b - (1 << k)][y + b - (1 << k)][k]);
        cout << MX - MN << '\n'; // 本题求最值之差
    }
}
```

#### 求任意子矩阵最值

```cpp
// https://vjudge.net/problem/HDU-2888
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 300 + 5;

int n, m;
int mx[N][N][9][9];
int mylog[N];
int a[N][N];

void solve() {
    // cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            mx[i][j][0][0] = a[i][j];
        }
    }
    for (int j = 1; j <= m; j++) {
        for (int k = 1; (1 << k) <= n; k++) {
            for (int i = 1; i + (1 << k) - 1 <= n; i++) {
                mx[i][j][k][0] = max(mx[i][j][k - 1][0], mx[i + (1 << (k - 1))][j][k - 1][0]);
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int k = 1; (1 << k) <= m; k++) {
            for (int j = 1; j + (1 << k) - 1 <= m; j++) {
                mx[i][j][0][k] = max(mx[i][j][0][k - 1], mx[i][j + (1 << (k - 1))][0][k - 1]);
            }
        }
    }
    for (int k1 = 1; (1 << k1) <= n; k1++) //枚举区间长度
        for (int k2 = 1; (1 << k2) <= m; k2++)
            for (int i = 1; i + (1 << k1) - 1 <= n; i++) //row
                for (int j = 1; j + (1 << k2) - 1 <= m; j++) //col
                    mx[i][j][k1][k2] = max(mx[i][j][k1 - 1][k2 - 1], max(mx[i + (1 << (k1 - 1))][j][k1 - 1][k2 - 1], max(mx[i][j + (1 << (k2 - 1))][k1 - 1][k2 - 1], mx[i + (1 << (k1 - 1))][j + (1 << (k2 - 1))][k1 - 1][k2 - 1])));
    int q;
    cin >> q;
    while (q--) {
        int p, q, x, y;
        cin >> p >> q >> x >> y;
        if (p == x && q == y) {
            cout << a[x][y] << " yes\n";
            continue;
        }
        int MX = 0;
        int dx = x - p + 1, dy = y - q + 1;
        int kx = mylog[dx], ky = mylog[dy];
        MX = max(MX, mx[p][q][kx][ky]);
        MX = max(MX, mx[p][y - (1 << ky) + 1][kx][ky]);
        MX = max(MX, mx[x - (1 << kx) + 1][q][kx][ky]);
        MX = max(MX, mx[x - (1 << kx) + 1][y - (1 << ky) + 1][kx][ky]);
        cout << MX << " ";
        if (MX == a[p][q] || MX == a[x][y] || MX == a[p][y] || MX == a[x][q])
            cout << "yes\n";
        else
            cout << "no\n";
    }
}
int main()
{
    mylog[0] = -1;
    for (int i = 1; i <= 300; i++) mylog[i] = mylog[i >> 1] + 1;
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int _T = 1;
    // cin >> _T;
    while (cin >> n >> m)
        solve();
    return 0;
}
```

## 字符串哈希

### 普通版哈希

```cpp
#define ull unsigned long long
using namespace std;
const int N = 1e4 + 5;
const ull P = 131;
ull a[N];
char s[N];
ull Hash(char* s) { // BKDRHash
    ull H = 0;
    int n = strlen(s);
    for (int i = 0; i < n; i++)
        H = H * P + s[i] - 'a' + 1; // 自然溢出
    return H;
}

ull get_hash(ull L, ull R) { return H[R] - H[L - 1] * P[R - L + 1]; }
```

### 双模数哈希

```cpp
// 随机质数列表：1111111121、1211111123、1311111119
const int N = 1 << 21;
static const int mod1 = 1E9 + 7, base1 = 127;
static const int mod2 = 1E9 + 9, base2 = 131;
using U = Zmod<mod1>;
using V = Zmod<mod2>;
vector<U> val1;
vector<V> val2;
void init(int n = N) {
    val1.resize(n + 1), val2.resize(n + 2);
    val1[0] = 1, val2[0] = 1;
    for (int i = 1; i <= n; i++) {
        val1[i] = val1[i - 1] * base1;
        val2[i] = val2[i - 1] * base2;
    }
}
struct String {
    vector<U> hash1;
    vector<V> hash2;
    string s;
    
    String(string s_) : s(s_), hash1{1}, hash2{1} {
        for (auto it : s) {
            hash1.push_back(hash1.back() * base1 + it);
            hash2.push_back(hash2.back() * base2 + it);
        }
    }
    pair<U, V> get() { // 输出整串的哈希值
        return {hash1.back(), hash2.back()};
    }
    pair<U, V> substring(int l, int r) { // 输出子串的哈希值
        if (l > r) swap(l, r);
        U ans1 = hash1[r + 1] - hash1[l] * val1[r - l + 1];
        V ans2 = hash2[r + 1] - hash2[l] * val2[r - l + 1];
        return {ans1, ans2};
    }
    pair<U, V> modify(int idx, char x) { // 修改 idx 位为 x
        int n = s.size() - 1;
        U ans1 = hash1.back() + val1[n - idx] * (x - s[idx]);
        V ans2 = hash2.back() + val2[n - idx] * (x - s[idx]);
        return {ans1, ans2};
    }
};
```

### 哈希判断回文串

```cpp
#define ull unsigned long long

int n;
char s[N], t[N];
ull ans, PP = 131, f[N], g[N], P[N];

void init() {
    P[0] = 1;
    for (int i = 1; i <= n; i++) t[i] = s[n - i + 1];
    for (int i = 1; i <= n; i++) P[i] = P[i - 1] * PP;
    for (int i = 1; i <= n; i++) f[i] = f[i - 1] * PP + s[i];
    for (int i = n; i >= 1; i--) g[i] = g[i + 1] * PP + t[i];
}

bool isPalindrome_even(int l, int r) { // 长度为偶数
    int mid = (l + r) >> 1;
    int x = l + mid - 1; // 以s[x]为中心
    ull a = f[x] - f[x - mid] * P[mid];
    ull b = g[x + 1] - g[x + 1 + mid] * P[mid];
    return a == b;
}
bool isPalindrome_odd(int l, int r) { // 长度为奇数
    int mid = ((l + r) >> 1);
    int x = l + mid; // 以s[x]为中心
    ull a = f[x] - f[x - mid] * P[mid];
    ull b = g[x + 1] - g[x + 1 + mid] * P[mid];
    return a == b;
}
```
